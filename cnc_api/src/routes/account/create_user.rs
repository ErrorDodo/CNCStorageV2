use crate::models::invites::Invite;
use crate::models::users::{CreateUserError, NewUser, User};
use crate::schema::{invites, users};
use crate::{db::DbPool, models::users::UserDTO};
use actix_web::{http::StatusCode, web, HttpResponse};
use bcrypt::{hash, DEFAULT_COST};
use diesel::prelude::*;
use diesel::result::Error as DieselError;
use log::{error, info};
use uuid::Uuid;

impl From<DieselError> for CreateUserError {
    fn from(err: DieselError) -> Self {
        CreateUserError::DieselError(err)
    }
}

impl From<bcrypt::BcryptError> for CreateUserError {
    fn from(err: bcrypt::BcryptError) -> Self {
        CreateUserError::BcryptError(err)
    }
}

pub async fn create_user(
    user_dto: web::Json<UserDTO>,
    pool: web::Data<DbPool>,
) -> Result<HttpResponse, actix_web::Error> {
    let mut conn = pool.get().expect("couldn't get db connection from pool");

    let result = conn.transaction::<_, CreateUserError, _>(|conn| {
        if users::table
            .filter(users::columns::username.eq(&user_dto.username))
            .first::<User>(conn)
            .optional()?
            .is_some()
        {
            return Err(CreateUserError::UsernameTaken);
        }

        let invite = invites::table
            .filter(invites::columns::invite_code.eq(&user_dto.invite_code))
            .first::<Invite>(conn)
            .optional()?;

        if let Some(ref invite) = invite {
            if invite.has_been_used {
                return Err(CreateUserError::InviteCodeUsed);
            }
        } else {
            // Handle the case where the invite is not found (optional)
            return Err(CreateUserError::DieselError(DieselError::NotFound));
        }

        let invite = invite.unwrap();

        let hashed_password =
            hash(&user_dto.password, DEFAULT_COST).map_err(|e| CreateUserError::BcryptError(e))?;

        let new_user = NewUser::new(
            &user_dto.username,
            &hashed_password,
            chrono::Utc::now().naive_utc(),
            Some(invite.generated_by_user_id),
            false,
            false,
        );

        let user_id: Uuid = diesel::insert_into(users::table)
            .values(&new_user)
            .returning(users::columns::user_id)
            .get_result(conn)
            .map_err(|e| CreateUserError::DieselError(e))?;

        diesel::update(invites::table.find(invite.invite_id))
            .set((
                invites::columns::has_been_used.eq(true),
                invites::columns::date_used.eq(chrono::Utc::now().naive_utc()),
                invites::columns::used_by_user_id.eq(user_id),
            ))
            .execute(conn)
            .map_err(|e| CreateUserError::DieselError(e))?;

        Ok((invite, user_id))
    });

    match result {
        Ok((invite, _user_id)) => {
            info!(
                "User Created Successfully: {}. Invite Code: {}, Generated by User ID: {}",
                user_dto.username, invite.invite_code, invite.generated_by_user_id,
            );
            Ok(HttpResponse::Ok().json("User created successfully"))
        }
        Err(CreateUserError::UsernameTaken) => {
            error!("Username already taken");
            Ok(HttpResponse::build(StatusCode::BAD_REQUEST).body("Username already taken"))
        }
        Err(CreateUserError::InviteCodeUsed) => {
            error!("Invite code has already been used");
            Ok(HttpResponse::build(StatusCode::BAD_REQUEST)
                .body("Invite code has already been used"))
        }
        Err(CreateUserError::DieselError(_)) => {
            error!("Database transaction error");
            Ok(HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR)
                .body("Database transaction error"))
        }
        Err(CreateUserError::BcryptError(_)) => {
            error!("Error hashing password");
            Ok(HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR)
                .body("Error hashing password"))
        }
    }
}
