use crate::models::invites::Invite;
use crate::models::users::{NewUser, User};
use crate::schema::{invites, users};
use crate::{db::DbPool, models::users::UserDTO};
use actix_web::{web, HttpResponse};
use bcrypt::{hash, DEFAULT_COST};
use diesel::prelude::*;
use diesel::result::Error as DieselError;
use log::{error, info};
use uuid::Uuid;

pub async fn create_user(
    user_dto: web::Json<UserDTO>,
    pool: web::Data<DbPool>,
) -> Result<HttpResponse, actix_web::Error> {
    let mut conn = pool.get().expect("couldn't get db connection from pool");

    let created_user_info = conn
        .transaction::<_, DieselError, _>(|conn| {
            let existing_user = users::table
                .filter(users::columns::username.eq(&user_dto.username))
                .first::<User>(conn)
                .optional()?;

            if existing_user.is_some() {
                error!("Username already taken");
                return Err(DieselError::NotFound);
            }

            let invite = invites::table
                .filter(invites::columns::invite_code.eq(&user_dto.invite_code))
                .first::<Invite>(conn)?;

            if invite.has_been_used {
                error!("Invite code has already been used");
                return Err(DieselError::NotFound);
            }

            let hashed_password =
                hash(&user_dto.password, DEFAULT_COST).map_err(|_| DieselError::NotFound)?;

            let new_user = NewUser {
                username: &user_dto.username,
                password_hash: &hashed_password,
                date_registered: chrono::Utc::now().naive_utc(),
                invited_by_user_id: Some(invite.generated_by_user_id),
                is_admin: false,
                is_moderator: false,
            };

            let user_id: Uuid = diesel::insert_into(users::table)
                .values(&new_user)
                .returning(users::columns::user_id)
                .get_result(conn)?;

            diesel::update(invites::table.find(invite.invite_id))
                .set((
                    invites::columns::has_been_used.eq(true),
                    invites::columns::date_used.eq(chrono::Utc::now().naive_utc()),
                    invites::columns::used_by_user_id.eq(user_id),
                ))
                .execute(conn)?;

            Ok((invite, user_id))
        })
        .map_err(|e| {
            error!("Transaction error: {}", e);
            actix_web::error::ErrorInternalServerError(format!("Transaction error: {}", e))
        })?;

    let (invite, _user_id) = created_user_info;

    info!(
        "User Created Successfully: {}. Invite Code: {}, Generated by User ID: {}",
        user_dto.username, invite.invite_code, invite.generated_by_user_id,
    );
    Ok(HttpResponse::Ok().json("User created successfully"))
}
